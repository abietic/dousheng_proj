// Code generated by hertz generator.

package core

import (
	"context"
	"strconv"

	"dousheng/common/errno"
	common "dousheng/router/biz/model/common"
	core "dousheng/router/biz/model/core"
	"dousheng/router/kitex_gen/auth"
	"dousheng/router/kitex_gen/userinfo"

	// "sync/atomic"
	"dousheng/router/rpc"

	"dousheng/router/jwtmiddleware"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"

	jwt "github.com/golang-jwt/jwt/v4"
	jwtextra "github.com/hertz-contrib/jwt"
)

var id int64 = 1
var name = "zhanglei"
var followCount int64 = 10
var followerCount int64 = 5
var isFollow = true

// UsersLoginInfo use map to store user info, and key is username+password for demo
// user data will be cleared every time the server starts
// test data: username=zhanglei, password=douyin
var UsersLoginInfo = map[string]common.User{
	"zhangleidouyin": {
		Id:            &id,
		Name:          &name,
		FollowCount:   &followCount,
		FollowerCount: &followerCount,
		IsFollow:      &isFollow,
	},
}

// var userIdSequence = int64(1)

var (
	failStatusCode int32 = 1
	failStatusMsg        = "User doesn't exist"
)

// LoginHandler .
// @router /douyin/user/login/ [POST]
func LoginHandler(ctx context.Context, c *app.RequestContext) {
	// var err error
	// var req core.DouyinUserLoginRequest
	// err = c.BindAndValidate(&req)
	// if err != nil {
	// 	c.String(consts.StatusBadRequest, err.Error())
	// 	return
	// }

	// resp := new(core.DouyinUserLoginResponse)

	// // 先做rpc调用
	// payload, err := jwtmiddleware.AuthMiddleware.Authenticator(ctx, c)
	// if err != nil {
	// 	if ev, ok := err.(errno.ErrNo); ok {
	// 		var errCode int32 = int32(ev.ErrCode)
	// 		resp.StatusCode = &errCode
	// 		resp.StatusMsg = &ev.ErrMsg
	// 	} else {
	// 		var errCode int32 = errno.AuthorizationFailedErrCode
	// 		resp.StatusCode = &errCode
	// 		resp.StatusMsg = &errno.AuthorizationFailedErr.ErrMsg
	// 	}
	// 	c.JSON(consts.StatusOK, resp)
	// 	return
	// }

	// // Create the token
	// token := jwt.New(jwt.GetSigningMethod(jwtmiddleware.AuthMiddleware.SigningAlgorithm))
	// claims := token.Claims.(jwt.MapClaims)

	// var uid int64
	// for key, value := range jwtmiddleware.AuthMiddleware.PayloadFunc(payload) {
	// 	claims[key] = value
	// 	if key == jwtmiddleware.UserIDKey {
	// 		uid = value.(int64)
	// 	}
	// }

	// expire := jwtmiddleware.AuthMiddleware.TimeFunc().Add(jwtmiddleware.AuthMiddleware.Timeout)
	// claims["exp"] = expire.Unix()
	// claims["orig_iat"] = jwtmiddleware.AuthMiddleware.TimeFunc().Unix()
	// tokenString, err := token.SignedString(jwtmiddleware.AuthMiddleware.Key)
	// if err != nil {
	// 	var errCode int32 = errno.AuthorizationFailedErrCode
	// 	resp.StatusCode = &errCode
	// 	resp.StatusMsg = &errno.AuthorizationFailedErr.ErrMsg
	// 	c.JSON(consts.StatusOK, resp)
	// 	return
	// }
	// resp.Token = &tokenString
	// resp.UserId = &uid
	// resp.StatusCode = &successStatusCode

	// c.JSON(consts.StatusOK, resp)

	jwtmiddleware.AuthMiddleware.LoginHandler(ctx, c)
}

// RegisterHandler .
// @router /douyin/user/register/ [POST]
func RegisterHandler(ctx context.Context, c *app.RequestContext) {
	var err error
	var req core.DouyinUserRegisterRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(core.DouyinUserRegisterResponse)

	ul, pl := len(*req.Username), len(*req.Username)

	if ul == 0 || pl == 0 || ul > jwtmiddleware.MaxUsernameLen || pl > jwtmiddleware.MaxPasswordLen {
		var errCode int32 = errno.ParamErrCode
		resp.StatusCode = &errCode
		resp.StatusMsg = &errno.ParamErr.ErrMsg
		c.JSON(consts.StatusOK, resp)
		return
	}

	user_auth, err := rpc.Register(ctx, &auth.RegisterRequest{Username: *req.Username, Password: *req.Password})
	// _, err = rpc.Register(ctx, &auth.RegisterRequest{Username: *req.Username, Password: *req.Password})
	if err != nil {
		var errCode int32
		if ev, ok := err.(errno.ErrNo); ok {
			errCode = int32(ev.ErrCode)
			resp.StatusCode = &errCode
			resp.StatusMsg = &ev.ErrMsg
		} else {
			errCode = errno.RegisterErrCode
			resp.StatusCode = &errCode
			resp.StatusMsg = &errno.RegisterErr.ErrMsg
		}
		c.JSON(consts.StatusOK, resp)
		return
	}
	// jwtmiddleware.AuthMiddleware.LoginHandler(ctx, c)
	// return
	// Create the token
	token := jwt.New(jwt.GetSigningMethod(jwtmiddleware.AuthMiddleware.SigningAlgorithm))
	claims := token.Claims.(jwt.MapClaims)

	for key, value := range jwtmiddleware.AuthMiddleware.PayloadFunc(user_auth) {
		claims[key] = value
	}

	expire := jwtmiddleware.AuthMiddleware.TimeFunc().Add(jwtmiddleware.AuthMiddleware.Timeout)
	claims["exp"] = expire.Unix()
	claims["orig_iat"] = jwtmiddleware.AuthMiddleware.TimeFunc().Unix()
	tokenString, err := token.SignedString(jwtmiddleware.AuthMiddleware.Key)
	if err != nil {
		var errCode int32 = errno.AuthorizationFailedErrCode
		resp.StatusCode = &errCode
		resp.StatusMsg = &errno.AuthorizationFailedErr.ErrMsg
		c.JSON(consts.StatusOK, resp)
		return
	}
	var errCode int32 = errno.SuccessCode
	resp.StatusCode = &errCode
	resp.StatusMsg = &errno.Success.ErrMsg
	resp.Token = &tokenString
	resp.UserId = &user_auth.UserId
	c.JSON(consts.StatusOK, resp)
}

// UserHandler .
// @router /douyin/user/ [GET]
func UserHandler(ctx context.Context, c *app.RequestContext) {
	var err error
	var req core.DouyinUserRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(core.DouyinUserResponse)

	// 读出token的数据
	tk, err := jwtmiddleware.AuthMiddleware.ParseTokenString(*req.Token)
	if err != nil {
		var errCode int32 = errno.AuthorizationFailedErrCode
		resp.StatusCode = &errCode
		resp.StatusMsg = &errno.AuthorizationFailedErr.ErrMsg
		c.JSON(consts.StatusOK, resp)
		return
	}
	claims := jwtextra.ExtractClaimsFromToken(tk)
	visitorID, err := strconv.ParseInt(claims[jwtmiddleware.UserIDKey].(string), 10, 64)
	hostID := req.GetUserId()
	if err != nil {
		var errCode int32 = errno.AuthorizationFailedErrCode
		resp.StatusCode = &errCode
		resp.StatusMsg = &errno.AuthorizationFailedErr.ErrMsg
		c.JSON(consts.StatusOK, resp)
		return
	}
	userInfo, err := rpc.GetUserInfo(ctx, &userinfo.UesrInfoRequest{VisitorUserId: visitorID, HostUserId: hostID})
	if err != nil {
		var errCode int32
		if ev, ok := err.(errno.ErrNo); ok {
			errCode = int32(ev.ErrCode)
			resp.StatusCode = &errCode
			resp.StatusMsg = &ev.ErrMsg
		} else {
			errCode = errno.ServiceErrCode
			resp.StatusCode = &errCode
			errStr := err.Error()
			resp.StatusMsg = &errStr
		}
		c.JSON(consts.StatusOK, resp)
		return
	}
	var errCode int32 = errno.SuccessCode
	resp.StatusCode = &errCode
	resp.StatusMsg = &errno.Success.ErrMsg
	resp.User = &common.User{
		Id:              req.UserId,
		Name:            &userInfo.Username,
		FollowCount:     &userInfo.FollowCount,
		FollowerCount:   &userInfo.FollowerCount,
		IsFollow:        &userInfo.IsFollow,
		Avatar:          &userInfo.Avatar,
		BackgroundImage: &userInfo.BackgroundImage,
		Signature:       &userInfo.Signature,
		TotalFavorited:  &userInfo.TotalFavorited,
		WorkCount:       &userInfo.WorkCount,
		FavoriteCount:   &userInfo.FavoriteCount,
	}

	c.JSON(consts.StatusOK, resp)
}
